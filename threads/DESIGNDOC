			+--------------------+
			|        CS 140      |
			| PROJECT 1: THREADS |
			|   DESIGN DOCUMENT  |
			+--------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Stefan Geyer <stefan.geyer@student.tuwien.ac.at>
Markus Hinterleitner <e01631852@student.tuwien.ac.at>
Rene Hollander <rene.hollander@tuwien.ac.at>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.


			 PRIORITY SCHEDULING
			 ===================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct thread
  {
    ...

    int priority;                       /* Effective Priority. Either base or the priority of a donor */
    int base_priority;                  /* Base priority. This value is set on calling thread_set_priority */
    struct list priority_donations;     /* Priority donations. All current donations stored in a list*/
    struct lock *lock_waiting;          /* A lock the thread might be waiting for. */
    struct semaphore *sema_waiting;     /* A lock the thread might be waiting for. */

    struct list_elem readyelem;         /* List element for ready threads list. */

    ...
  }

Each thread tracks it's own donations.

>> B2: Explain the data structure used to track priority donation.
>> Use ASCII art to diagram a nested donation.  (Alternately, submit a
>> .png file.)

struct donation
  {
     struct lock *lock; /* The lock the donor is waiting for which is held by the receiver */
     int priority; /* The donated priority */
     struct list_elem elem;
  };

A donation is performed when a thread wants to acquire a lock which is currently held by a different thread.
We therefore need to maintain the value of priority donated keyed by the lock which the donor wants to acquire.

Nested donation:

----------    ----------
| Lock A |    | Lock B |
----------    ----------

----------------------    -------------------------    ----------------------
|                    |    |                       |    |                    |
|        T 1         |    |          T 2          |    |        T 3         |
|                    |    |                       |    |                    |
|  priority = 32     |    |  priority = 32        |    |  priority = 36     |
|  holds = A         |    |  holds = B            |    |  holds = NULL      |
|  lock_waiting = B  |    |  lock_waiting = NULL  |    |  lock_waiting = A  |
|                    |    |                       |    |                    |
----------------------    -------------------------    ----------------------

Thread 3 tries to acquire lock A which is held by thread 1. Thread 1 is also waiting on lock B to be released which is
held by thread 2. (At this point thread 1 has already donated it's priority to thread 2). Thread 3 donates it's priority
to thread 1. Since it is known which lock thread 1 is waiting on, we can recursively perform the donation and also donate
to thread 2.

---- ALGORITHMS ----

>> B3: How do you ensure that the highest priority thread waiting for
>> a lock, semaphore, or condition variable wakes up first?

Scheduling: Order the list of ready threads by priority and take first element (Sort ready_list by effective priority)

Semaphores maintain a list of waiting threads to determine which one gets unblock next.
This list will be sorted by priority to make sure the thread with the highest priority gets picked next.

>> B4: Describe the sequence of events when a call to lock_acquire()
>> causes a priority donation.  How is nested donation handled?

1) Attempt to acquire the lock using sema_try_down (we cannot use sema_down for the following since we cannot access the lock from that function).
2) On failure: insert self into the waiting list sorted by effective priority and perform a priority donation to the current lock holder.
3) Maintain information on which lock the thread is waiting. This information can be used to perform a nested (recursive) donation.
4) Once we can acquire the lock, drop the reference to the lock we are waiting on and set self as lock holder.

>> B5: Describe the sequence of events when lock_release() is called
>> on a lock that a higher-priority thread is waiting for.

1) Iterate through the holder's donations and remove those with matching locks (donation->lock == lock_to_release)
2) Adjust the holder's priority accordingly
3) Yield, so that the thread with the highest priority (which might have waited for this lock to be released) gets to act.

---- SYNCHRONIZATION ----

>> B6: Describe a potential race in thread_set_priority() and explain
>> how your implementation avoids it.  Can you use a lock to avoid
>> this race?

1) Thread A and thread B have the same priority
2) Thread A tries to increase it's own priority but a timer interrupt schedules thread B before A can set the actual value.
3) Thread B is now running, while A should technically already have a higher priority.

=> Disable interrupts to avoid the possible timer interrupt.

---- RATIONALE ----

>> B7: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

We first tried to keep track of the relative donation differences between the donor's and the holder's priority. We
would store the results in a stack only needing to pop the top when a lock is released. Sadly this design does not
work, als the relative offsets become invalid on resetting the thread's own base priority.
We then switched to our current design, where we keep track of the absolute priorities.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?